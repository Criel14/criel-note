# 计算机网络

记一些比较重要的容易忘的，详细还是看小林或JavaGuide



## 网络模型

### 网络分层及常见协议

![各层及常见协议](image/各层及常见协议.png)

> 图来自小林，其中应用层的DHCP协议打错了



### 输入网址到网页显示发生了什么

1. 解析URL
   - 生成HTTP请求报文
2. 获取IP地址
   - 先本机：浏览器缓存 → 操作系统缓存（内存中） → hosts文件
   - 再DNS：本地DNS服务器 → 根域名服务器 → 顶级域名服务器 → 权威域名服务器
3. 数据报封装
   - IP头部 + TCP头部 + HTTP头部 + 数据
4. 找下一跳的MAC地址
   - ARP协议
   - 数据报再加上MAC头部
   - （到达下一跳之后继续找下一跳的MAC地址）
5. 网卡
   - 在数据报开头加上**报头**和**起始帧分界符**，在末尾加上用于检测错误的**帧校验序列`FCS`**
   - ![网卡发送数据](image/网卡发送数据.webp)

6. 交换机
   - 交换机根据 **MAC 地址表**查找 MAC 地址，然后将信号发送到相应的端口
   - 交换机本身不具有MAC地址
7. 路由器
   - 路由器根据**路由表**转发
   - 原本的MAC头部被丢弃，加上新的MAC头部，这个过程需要ARP协议
     - 因此，对于1个数据报，**源IP地址和目标IP一直不变，而MAC地址一直在变**
8. 接收方一层一层解析、去掉头部，获得数据信息
9. 数据报可以发送后，后续就是TCP握手，TLS握手，服务端发送网页资源文件



报文层层封装：

![完整报文](完整报文.webp)



### 网卡与操作系统

具体看小林：https://xiaolincoding.com/network/1_base/how_os_deal_network_package.html#linux-%E6%8E%A5%E6%94%B6%E7%BD%91%E7%BB%9C%E5%8C%85%E7%9A%84%E6%B5%81%E7%A8%8B



收到数据包时，关于数据包的**去头操作**：

- 当网卡接收到以太网帧时，**硬件**将完成物理层和链路层的基本处理，包括 CRC 校验、**MAC 地址**过滤，并通过 **DMA** 将合法帧（完整的帧）**写入系统内存**，然后触发中断通知操作系统；
- 操作系统内核的网络驱动会在**硬中断**（Hard IRQ）中简单应答，并在**软中断**（Soft IRQ/NAPI）中将帧封装到 `sk_buff` 结构，依次剥除**MAC头、IP 头、传输层头**并完成协议 demux（多路复用的逆过程），最终通过套接字接口将应用层数据交付给用户进程。
  - 操作系统中是通过**调整指针**（而非物理拷贝）来剥头；
- 总结：也就是网卡做了**数据链路层的校验**，操作系统完成去头和后续操作（软中断）；



对于**数据包的传递**：从网卡开始，**DMA写入系统内存**（内核空间），**CPU拷贝到用户空间**；

- 数据包进入系统内存后，操作系统内核调用函数做处理
  - 在传输层的头部中，操作系统根据【源 IP、源端口、目的 IP、目的端口】四元组，在 **socket 哈希表**中查找对应的socket（底层是一个 `struct sock`结构）；
  - 然后去掉各层的头部；
  - 再将去完头部的数据包放入该 **socket 的接收队列**；

- 完成上述操作后，用户进程被应用程序唤醒，接收Socket；
  - 当新的数据段排入 socket 的接收队列后，内核唤醒正在阻塞的线程；
    - tip：1个socket有1个接收队列，也就是1个socket可以接收多个数据包
  - 用户进程一旦执行 `read()` 或 `recv()`，**CPU**会将队列中的数据，即`sk_buff`，拷贝到用户提供的缓冲区；



**软中断**与**硬中断**

- 当数据包通过DMA写入内存后，网卡向CPU发起**硬中断**：
  - 需要先「**暂时屏蔽中断**」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。
  - 接着，发起「**软中断**」，然后恢复刚才屏蔽的中断。

- **软中断**：
  - 内核中的 ksoftirqd **线程**专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来**轮询处理**数据。
  - ksoftirqd 线程会从环形缓冲区 Ring Buffer 中获取一个**数据帧**，用 `sk_buff` 表示，从而可以**作为一个网络包**交给网络协议栈进行逐层处理。

> 基本的定义：
>
> - **硬中断**是由**硬件**设备（如网卡、定时器、键盘）或处理器本身（如异常）**发起**的中断请求，CPU 收到后立即中断当前执行流，并跳转到对应的中断处理函数（ISR）执行；
>
> - **软中断**是 Linux 提供的一种轻量级**异步处理机制**，属于内核底半部，专门用于在硬中断处理后或特定时机延后执行较不紧急的任务，如网络报文收发、定时器管理等；





## 应用层

### HTTP报文

`回车 + 换行` 用来作为不同消息之间的边界，因为TCP是面向字节流的，不会按照内容去拆分数据包，会出现**”粘包”**问题，需要在应用层面通过特定标识来作为消息边界；

![HTTP报文](image/HTTP报文.webp)



### HTTP头常见字段

#### 常见请求头字段

- **Host**: 指定请求的目标主机名和端口，用于虚拟主机场景
- **User-Agent**: 标识发起请求的客户端应用（浏览器、爬虫等）及其版本信息
- **Accept**: 告知服务器客户端可接受的媒体类型，如 `text/html`、`application/json` 等
- **Accept-Language**: 指定客户端偏好的自然语言，用于内容本地化选择
- **Accept-Encoding**: 声明客户端支持的传输编码（压缩算法），如 `gzip`、`deflate`、`br`
- **Authorization**: 携带访问受保护资源所需的凭证，如 `Bearer <token>` 或 `Basic <credentials>`
- **Cookie**: 向服务器发送此前设置的会话或跟踪 Cookie 
- **Referer**: （RFC 拼写有误，应为 Referrer，但由于历史原因，所以保留）表明当前请求来源的页面 URL 
- **Connection**: 控制网络连接行为，如 `keep-alive` 或 `close` 
- **Cache-Control**: 在请求中可携带 `no-cache`、`max-age=0` 等指令，控制客户端与中间缓存的缓存策略 

```http
GET /index.html HTTP/1.1
Host: www.example.com:8080
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Accept-Encoding: gzip, deflate, br
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Cookie: sessionId=abc123; theme=light
Referer: https://www.google.com/
Connection: keep-alive
Cache-Control: no-cache
```



#### 常见响应头字段

- **Date**: 响应生成的日期和时间，采用 GMT 时区格式 
- **Server**: 标识服务器软件及版本信息 
- **Content-Type**: 响应主体的媒体类型及字符集，例如 `text/html; charset=UTF-8` 
- **Content-Length**: 响应主体的字节长度 
- **Set-Cookie**: 服务器设置或更新客户端 Cookie 
- **ETag**: 资源的唯一标识符，用于条件请求与缓存验证 
- **Last-Modified**: 资源的最后修改时间，配合 `If-Modified-Since` 实现条件请求 
- **Cache-Control**: 在响应中可携带 `public`、`private`、`max-age=3600` 等缓存指令 
- **Connection**: 控制本次连接是否保持或关闭 

```http
HTTP/1.1 200 OK
Date: Fri, 25 Apr 2025 08:30:00 GMT
Server: Apache/2.4.46 (Ubuntu)
Content-Type: text/html; charset=UTF-8
Content-Length: 1024
Set-Cookie: sessionId=def456; HttpOnly; Secure
ETag: "5d8c72a5edda3"
Last-Modified: Thu, 24 Apr 2025 15:20:10 GMT
Cache-Control: public, max-age=3600
Connection: keep-alive

<html>
  <!-- 页面内容 -->
</html>
```



### HTTP版本对比

#### **HTTP 1.0**

> 短连接

- **默认使用短连接** 
  - 客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接；
  - 当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 TCP 连接，这样就会导致有大量的“握手报文”和“挥手报文”占用了带宽；
- 对**数据压缩**的选项提供的不多，不支持压缩细节的选择，也无法区分端到端（end-to-end）压缩或者是逐跳（hop-by-hop）压缩

#### **HTTP 1.1**

> 无头部压缩、纯文本传输、管线化（队头阻塞）、长连接

- **默认长连接模式**

  - 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接；

  - 如果 TCP 连接一直保持的话也是对资源的浪费，因此，一些服务器软件（如 Apache）还会支持超时时间的时间。在超时时间之内没有新的请求达到，TCP 连接才会被关闭；

  - >其实 HTTP/1.0 仍提供了长连接选项，即在请求头中加入**`Connection: Keep-alive`**。同样的，在 HTTP/1.1 中，如果不希望使用长连接选项，也可以在请求头中加入**`Connection: close`**；

- DNS允许**多个主机名绑定到同一个 IP 地址**上，但是 HTTP/1.0 并没有考虑这个问题

  - HTTP/1.1 在请求头中加入了`Host`字段，表示主机名；

  - ```http
    GET /home.html HTTP/1.1
    Host: example1.org
    ```

- **范围请求**

  - 在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接；防止出现“客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了”

  - ```http
    GET /path/to/resource HTTP/1.1
    Host: example.com
    Range: bytes=0-499,1000-1499
    ```

- 管道（管线化）

  - 可以实现防止“一发一收”的情况，但是接收的时候必须按顺序，如果第一个丢失了，后面的会阻塞，这个就是1.1的**队头阻塞**（在应用层的队头阻塞）
  - ![HTTP1.1管道](image/HTTP1.1管道.png)

- **压缩了报文主体，没有压缩头部**

- **HTTP帧是ASCII码，纯文本**

#### **HTTP 2**

> 多路复用、头部压缩、二进制传输、服务端推送

- **多路复用**

  - 解决了1.1的队头阻塞问题，但是由于TCP会队头阻塞，所以并没有完全解决队头阻塞的问题；（现在是传输层的队头阻塞）

  - > TCP中发送的的**数据段**如果有1个丢失了，后面都会被阻塞，等待重传

  - ![HTTP2多路复用](image/HTTP2多路复用.png)

  - 是通过在HTTP首部加上**流标识符**实现的，这样报文就可以不用按顺序到达；

  - ![HTTP2多路复用-流标识符](image/HTTP2多路复用-流标识符.png)

- **头部压缩**

  - HTTP 2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。这就是所谓的 **HPACK** 算法：在客户端和服务器**同时维护一张头信息表**，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，**只发送索引号**，这样就提高速度了。
  - ![HTTP2头部压缩](image/HTTP2头部压缩.png)

- **二进制格式**

  - HTTP/2 不再像 HTTP/1.1 里ASCII的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame）：**头信息帧**（Headers Frame）和**数据帧**（Data Frame）

- **服务器推送**

  - 容易受到DDoS攻击
  - ![HTTP2服务器推送](image/HTTP2服务器推送.png)

#### **HTTP 3**

> QUIC、解决队头阻塞

- 使用基于UDP的QUIC
  - ![HTTP3协议层](image/HTTP3协议层.png)
- 整合TCP握手 + TLS握手
  - 所以HTTP3默认就是要加密的
  - ![HTTP3握手](image/HTTP3握手.png)
- 解决队头阻塞
  - UDP本身就没有队头阻塞，本身就可以多路复用，QUIC帧也是用**流标识符**
- 连接ID（Connection ID）
  - 网络改变时（如Wifi变4G），IP改变，但是可以通过连接ID识别，不需要再次握手





### DNS解析

注意：“只指路不带路”

![DNS解析](image/DNS解析.webp)



## 传输层

### TCP头部

![TCP头部](image/TCP头部.webp)

标志位：

- **ACK**（Acknowledgment）
  - 该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。
- **RST**（Reset）
  - 该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
- **SYN**（Synchronization）
  - 该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
- **FIN**（Finish）
  - 该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段



### TCP三次握手

![TCP三次握手](image/TCP三次握手.png)

#### 为什么是三次

- 双方都需要确认自己**成功接收 + 成功发送**
  - 第一次握手：服务端收到客户端的SEQ，则知道了自己**成功接收**；
  - 第二次握手：客户端收到服务端的ACK 和 SEQ，则知道了自己**成功接收 + 成功发送**，但是不响应第三次握手的话，服务端不知道自己成功发送；
  - 第三次握手：服务端收到客户端的ACK，则知道了自己**成功发送**；
- 服务端发送ACK和SEQ，可以和成1步，所以不需要四次握手，只需要三次；

- **避免历史连接**
  - 不能仅有两次握手；
  - 如果第二次握手就建立连接，也就是不需要客户端再一次确认，那么服务端接收到旧的握手请求，就会建立错误的连接，还会造成资源浪费的问题；
  - ![TCP三次握手防止历史连接](image/TCP三次握手防止历史连接.png)





### TCP四次挥手

重要过程：

- **服务端收到了 FIN 报文**，然后马上回复一个 ACK 确认报文，此时服务端进入 **CLOSE_WAIT** 状态。
  - 在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包**插入一个文件结束符 EOF 到接收缓冲区中**，服务端应用程序可以通过 **read** 调用来感知这个 FIN 包，这个 EOF 会被放在已排队等候的其他已接收的数据之后，所以必须要得**继续 read 接收缓冲区已接收的数据**；
- 接着，当服务端在 read 数据的时候，最后自然就会读到 EOF，接着 **read()** 就会返回 0，这时服务端应用程序如果有数据要发送的话，就发完数据后才调用关闭连接的函数，如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数，这时服务端就会发一个 FIN 包，这个 FIN 报文代表服务端不会再发送数据了，之后处于 **LAST_ACK** 状态；

![TCP四次挥手](image/TCP四次挥手.webp)

#### 为什么是四次

服务端发送ACK和FIN不能像握手一样合并成一次；

服务端收到客户端断开连接的请求时，**可能还有一些数据没有发完**，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务端到客户端的数据传送；



#### 2个特殊状态

tip：**ESTABLISHED** 表示正在通信，原意是“建立”

以客户端为挥手发起方，服务端为挥手接收方：

- **CLOSE_WAIT**

  - 服务端收到FIN ~ 服务端发出FIN

- **TIME_WAIT**

  - 客户端收到FIN ~ 客户端关闭连接

  - 从收到FIN开始，需要等待**2MSL**的时间

    - 第四次挥手时，客户端发送给服务端的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2MSL 的时间内收到了 FIN，就会重新发送 ACK 并**再次等待 2MSL**，防止 Server 没有收到 ACK 而不断重发 FIN。

      > **MSL(Maximum Segment Lifetime)** : 一个片段在网络中最大的存活时间，2MSL 就是**一个发送和一个回复**所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。
      >
      > TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。
      >
      > TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了。



#### 出现大量TIME_WAIT

在一般业务中，通常是客户端主动断开连接，但如果是**服务端主动断开连接**，那么有可能出现服务端出现大量处于TIME_WAIT状态的连接：

- 没有使用长连接，而是使用了**大量短连接**
  - 由于等待的2MSL是固定的，如果有大量的连接在一段时间内同时断开，就可能有大量的连接处于TIME_WAIT状态；
- 长连接请求达到上限
  - 如果QPS特别高，达到了**服务端**设置的上限（如 Tomcat、Nginx、Spring Cloud Gateway），就会**关闭长连接**，关闭就出现TIME_WAIT状态；
- HTTP**长连接超时**
  - 可能有大量客户端建立完连接后不再发送消息，也没有关闭连接，超过HTTP长连接超时时间后，服务端就会主动关闭大量连接，就可能有大量的连接处于TIME_WAIT状态；
  - ![HTTP长连接超时](image/HTTP长连接超时.webp)



#### 出现大量CLOSE_WAIT

被动关闭方（通常是服务器）收到客户端的 FIN，协议栈自动发送 ACK，并进入 CLOSE_WAIT，等待本地应用调用 close() 完成后续的 FIN 发送；

- 服务端的程序**长时间未调用 close 函数关闭连接**
- 业务逻辑阻塞或响应过慢，导致本应关闭的连接滞留



### TCP拥塞控制

#### 超时重传

![TCP拥塞控制超时重传](image/TCP拥塞控制超时重传.webp)

#### 快重传

快速恢复算法是认为，你还能**收到 3 个重复 ACK** 说明网络也不那么糟糕

![TCP拥塞控制快重传](image/TCP拥塞控制快重传.webp)



### TCP Keepalive

有2个名字相似但内容完全不同的概念：

- HTTP 的 **Keep-Alive** 也叫 **HTTP 长连接**，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。
- TCP 的 **Keepalive** 也叫 **TCP 保活机制**，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。

![TCP保活机制](image/TCP保活机制.webp)



